LLVM IR
=======

* История и цель создания
* Работа с IR: LLVM API (in-memory compiler IR), LLVM asm (.ll), bitcode (.bc)
* https://llvm.org/docs/LangRef.html

* Инструкции
  Большинство инструкций принимает два аргумента (операнда) и возвращает одно значение (трёхадресный код).
  Тип операндов всегда указывается явно и однозначно определяет тип результата (IR строго типизирован).
  Значения определяются текстовым идентификатором.
  Локальные значения (виртуальные регистры) обозначаются префиксом %

  %sum = add i32 %n, 5
  %diff = sub double %a, %b
  %z = add <4 x float> %v1, %v2 ; поэлементное сложение
  %cond = icmp eq %x, %y ; Сравнение целых чисел. Результат имеет тип i1.
  %success = call i32 @puts(i8* %str)

  Полный набор арифметических операций, побитовых логических операций и операций сдвига, а также специальные инструкции для работы с векторами.
  Операции приведения типов, которые явно кодируются специальными инструкциями

  Набор из 9 инструкций покрывает все возможные приведения между различными числовыми типами:
  целыми и с плавающей точкой, со знаком и без, различной разрядности
  Инструкции преобразования между целыми и указателями, а также универсальная инструкция для приведения типов bitcast

* Память
  Помимо значений-регистров, в LLVM есть и работа с памятью (стек).
  Значения в памяти адресуются типизированными указателями. Обратиться к памяти можно с помощью двух инструкций: load и store.

  %x.ptr = alloca double ; %x.ptr имеет тип double*
  %array = alloca float, i32 8 ; %array имеет тип float*, а не [8 x float]!

* Типы данных
  Примитивные типы: i1 (бит), i8 (байт), i32 (32-битное целое), i64, float, double и т.д.
  Производные типы:
  Указатели: i32* (указатель на 32-битное целое).
  Векторы: <4 x i32> (вектор из четырех 32-битных целых).
  Массивы: [10 x i8] (массив из 10 байт).
  Структуры: { i32, i8, float } (аналог struct в C).
  Функции: i32 (i32, i32) (функция, принимающая два i32 и возвращающая i32).

* Инструкции управления потоком выполнения (Terminator Instructions)
  br (Branch) -- безусловный или условный переход.
  br i1 %cond, label %if_true, label %if_false — условный переход.
  br label %next_block — безусловный переход.

  indirectbr Косвенный переход по адрес (Indirect Branch), вычисленному в runtime.
  indirectbr i8* %block_addr, [label %bb1, label %bb2]

  switch -- Многопутевое ветвление, аналогичное switch в C.

  ret -- возвращает управление из функции
  ret i32 5 — возвращает значение 5.
  ret void — возврат из функции, не возвращающей значения.

  invoke -- вызывает функцию, которая может потенциально выбросить исключение
  %result = invoke i32 @may_throw() to label %normal unwind label %exception

* Модуль
*   Функция
*     Базовый блок
*       Инструкция

Трансляция высокоуровневых конструкций
https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/

* Модуль
* Функции, переменные, константы, аргументы
* Присваивание, инфиксные выражения
* if-then-else
* while

Задание
=======

* Реализовать на llvm ir функцию вычисления GCD, переписать gcd.c на LLVM IR
* Объяснить трансляцию аргументов функции, цикла





